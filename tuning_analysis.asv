clc
clear all
close all

subject_id = 's3';
unit_region = 'AIP';

spike_sorting_type = '_unsorted_aligned_thr_-4.5';
flag_4S = true; % true = updated 4S action phase; false = original 2S action phase
flag_shuffled = false; % true = shuffled images task
flag_varied_sizes = false; % true for varied sizes task
flag_GB_images = false; % true for task using images of GB's own hands and real objects
flag_5050 = false; % true for 50% Go 50% NoGo trials
flag_combined = false; % true for combinations task

if ~flag_4S
    TaskCue = 'GraspObject';
    min_timebin_length = 134; % NOT VALID FOR 20230831    
elseif ~flag_shuffled
    TaskCue = 'GraspObject_4S_Action';
    min_timebin_length = 174;
else
    TaskCue = 'GraspObject_Shuffled';
    min_timebin_length = 174; 
end 

if flag_varied_sizes
    TaskCue = 'GraspObject_Varied_Size';
    min_timebin_length = 174;
end
if flag_GB_images
    TaskCue = 'GraspObject_GB_Images';
    min_timebin_length = 174;
end

if flag_5050
    TaskCue = 'GraspObject_5050';
    min_timebin_length = 174;
end

if flag_combined
    TaskCue = 'GraspObject_Combined';
    min_timebin_length = 174;
end

% Task Variables
% 4S data
Data = load(['C:\Users\macthurston\OneDrive - Kaiser Permanente\CaltechData\GraspObject_project\' subject_id '\Data\Table_' subject_id '_' TaskCue spike_sorting_type]);
Go_data = Data.Go_data;
color_info = {[.1176 .5333 .8980],[.8471 .1059 .3765],[1 .7569 .0275]};

% remove faulty sessions, if any
error_session = {};
if strcmp(subject_id, 's2')
    error_session = {'20231016'};
elseif strcmp(subject_id, 's3')
    error_session = {'20231207','20231212','20250212'};
elseif strcmp(subject_id, 's4')
    error_session = {'20240613'};
end 

if ~isempty(error_session)
    for session = 1:numel(error_session)
        err_session = error_session{session};
        condition = cellfun(@(x) strcmp(x, err_session), Go_data.session_date);
        Go_data = Go_data(~condition,:);
    end
end

% add Aperture Size column
if strcmp(TaskCue, 'GraspObject_Varied_Size')
    sizeKeywords = ['Small', 'Medium', 'Large'];
    Go_data.Aperture_Size = cell(height(Go_data),1);
    % Loop through each label and extract the size information
    for i = 1:height(Go_data)
        % Use regular expression to find the size keyword after the last underscore
        tokens = regexp(Go_data.LabelNames{i}, '_(Small|Medium|Large)$', 'tokens');
    
        if ~isempty(tokens)
            % tokens is a cell array; extract the size keyword from it
            Go_data.Aperture_Size{i} = tokens{1}{1};
        end
    end
end

if strcmp(TaskCue, 'GraspObject_Combined')
    Go_data.TrialType(strcmp(Go_data.TrialType, 'Unknown')) = {'Combined'}; % adds in Combined as Trial type
    % add in column with Object Type for Combined trials and original trial types (H, HO, O with Associated)
    % Loop through each label and extract the object information
    for i = 1:height(Go_data)
        % Use regular expression to find the size keyword after the last underscore
        tokens = regexp(Go_data.LabelNames{i}, '_(deck|block|rod|ball)$', 'tokens');
        
        if ~isempty(tokens)
            % tokens is a cell array; extract the size keyword from it
            Go_data.ObjectType{i} = tokens{1}{1};
        else 
            Go_data.ObjectType{i} = 'Associated';
        end
    end
    color_info = {[.3632 .2266 .6055],[.1176 .5333 .8980],[.8471 .1059 .3765],[1 .7569 .0275]}; % Combinations task (purple at beginning)
end

flagGoTrials = true; % false = No-Go

flagRegressionTuning = true;

if flagRegressionTuning
    analysis_type = 'LinearRegression';
else
    analysis_type = 'KruskalWallis';
end

flagBinPerBin = true;
multipleComparePhase = true;
flagTunedChannels = true;
flagSaveData = true;

%chose cue type:
taskCuesAll = {'Hand', 'Hand-Object', 'Object'};
if flag_combined
    taskCuesAll = {'Combined','Hand', 'Hand-Object', 'Object'};
end
sessions_all = unique(Go_data.session_date);
numSessions = numel(sessions_all);
phase_time_idx = Go_data.time_phase_labels{1,1};
numPhases = numel(unique(phase_time_idx));
phase_changes_idx = diff(phase_time_idx);
phase_changes(1) = 1;
phase_changes(2:numPhases) = find(phase_changes_idx) + 1;
phase_bin_ranges = {
    1:phase_changes(2)-1;                   % ITI
    phase_changes(2):phase_changes(3)-1;    % Cue
    phase_changes(3):phase_changes(4)-1;    % Delay
    phase_changes(4):numel(phase_time_idx)  % Action
};
phaseNames = {'ITI', 'Cue', 'Delay', 'Action'};

numUnitsPerSession = zeros(numSessions,1);

% Initialize cell arrays to store results
hand_ho_overlap_units_all = cell(numSessions,1);
object_ho_overlap_units_all = cell(numSessions,1);
object_hand_overlap_units_all = cell(numSessions,1);
object_hand_ho_overlap_units_all = cell(numSessions,1);

%uniqueApertureSize = unique(Go_data.Aperture_Size); % comment out when not varied sizes

%% Analysis
for n_session = 1:numSessions

    disp(['Classification session ' sessions_all{n_session} ]);  

    %find idx of current session day
    idxThisSession = ismember(Go_data.session_date, sessions_all(n_session));
        

    %extract data from selected brain area

     if strcmp('SMG', unit_region)
            SessionData = Go_data.SMG_Go(idxThisSession,:);
        elseif strcmp('PMV', unit_region) 
            SessionData = Go_data.PMV_Go(idxThisSession,:);
        elseif strcmp('S1', unit_region)
            SessionData = Go_data.S1X_Go(idxThisSession,:);
         elseif strcmp('M1', unit_region) 
            SessionData = Go_data.M1_Go(idxThisSession,:);
        elseif strcmp('AIP', unit_region)
            SessionData = Go_data.AIP_Go(idxThisSession,:);
        elseif strcmp('dlPFC', unit_region)
            SessionData = Go_data.dlPFC_Go(idxThisSession,:);
        else
            error([unit_region ' does not exist '])
     end

     % skip session days that are empty - relevant for S1 session 20230810
     if isempty(SessionData{1})
        continue
     end
    
    % % Z-scoring => calc the mean of the FR of each unit across all trials per timebin, not per phase)
    % num_trials = length(SessionData);
    % [num_timebins, num_units] = size(SessionData{1});
    % % reconfigure matrix to store all trials
    % all_data = NaN(num_timebins,num_units,num_trials); 
    % for t = 1:num_trials
    %     all_data(:,:,t) = SessionData{t}; % (timebins x units) for each trial
    % end
    % 
    % % Compute the mean and SD across trials
    % mean_fr = mean(all_data, 3); % Result is (timebins x units)
    % std_fr = std(all_data, 0, 3); % (timebins x units)
    % std_fr(std_fr == 0) = 1; % Avoid division by zero by setting std_fr to 1 where it's zero
    % 
    % % Z-score normalization: (X - mean) / std
    % z_scored_fr = (all_data - mean_fr) ./ std_fr; % (timebins x units x trials)
    % 
    % % Initialize the cell array
    % z_scored_data = cell(num_trials, 1);
    % 
    % % Fill the cell array with z-scored data
    % for t = 1:num_trials
    %     z_scored_data{t} = z_scored_fr(:,:,t); % Extract each trial's matrix
    % end 

    %labels 
    sessionLabels = Go_data.GoLabels(idxThisSession,:);
    
    %trialType
    trialTypeSession = Go_data.TrialType(idxThisSession,:);

    % grasp labels
    graspTypeSession = Go_data.GraspType(idxThisSession,:);

    %ApertureSize
    %apertureSizeSession = Go_data.Aperture_Size(idxThisSession,:);

    % object labels
    %objectTypeSession = Go_data.ObjectType(idxThisSession,:);

    %get idx for Go or NoGo trials
    GoNoGoidx =  logical(cell2mat(Go_data.TrialCue(idxThisSession,:)));
    timePhaseLabels = Go_data.time_phase_labels(idxThisSession);
    

    if flagGoTrials
        SessionData = SessionData(GoNoGoidx);
        %SessionData = z_scored_data(GoNoGoidx);
        sessionLabels = sessionLabels(GoNoGoidx);
        timePhaseLabels = timePhaseLabels(GoNoGoidx);
        trialTypeSession = trialTypeSession(GoNoGoidx);
        graspTypeSession = graspTypeSession(GoNoGoidx);
        %apertureSizeSession = apertureSizeSession(GoNoGoidx);
        %objectTypeSession = objectTypeSession(GoNoGoidx);
    else
        SessionData = z_scored_data(~GoNoGoidx);
        sessionLabels = sessionLabels(~GoNoGoidx);
        timePhaseLabels = timePhaseLabels(~GoNoGoidx);
        trialTypeSession = trialTypeSession(~GoNoGoidx);
    end
     
    % seperate data according to cue modality 
    unTrialType = unique(Go_data.TrialType);

    numUnitsPerSession(n_session) = size(SessionData{1},2);

    sessionLabels_modality = trialTypeSession;
    sessionLabels_grasp = graspTypeSession;
   % sessionLabels_size = apertureSizeSession;
    %sessionLabels_object = objectTypeSession;

    % Convert word labels (ie.,'Hand', 'HandObject', 'Object') to numerical values
    modality_labels = {'Combined','Hand', 'Hand_Object', 'Object'}; % 'Combined'
    grasp_labels = {'Lateral', 'MediumWrap', 'PalmarPinch', 'Sphere3Finger'};
    %size_labels = {'Small', 'Medium', 'Large'};
    %object_labels = {'block','rod','deck','ball'}; % numbering mirrors associated grasp

    % Initialize numerical labels
    sessionLabels_modality_num = zeros(size(sessionLabels_modality)); 
    sessionLabels_grasp_num = zeros(size(sessionLabels_grasp));
    %sessionLabels_size_num = zeros(size(sessionLabels_size));
    %sessionLabels_object_num = zeros(size(sessionLabels_object));

    % Loop through labels and assign numerical values
    for i = 1:length(modality_labels)
        sessionLabels_modality_num(strcmp(sessionLabels_modality, modality_labels{i})) = i;
    end  
    for i = 1:length(grasp_labels)
        sessionLabels_grasp_num(strcmp(sessionLabels_grasp, grasp_labels{i})) = i;
    end 
    % for i = 1:length(size_labels)
    %     sessionLabels_size_num(strcmp(sessionLabels_size, size_labels{i})) = i;
    % end
    % for i = 1:length(object_labels)
    %     sessionLabels_object_num(strcmp(sessionLabels_object, object_labels{i})) = i;
    % end 

    % % % % ADDRESSING UNEQUAL TRIAL NUMBERS % % %
    % % Number of repetitions for balancing
    % nRepeats = 10;  
    % 
    % % Preallocate containers
    % all_sumPhase              = cell(nRepeats,1);
    % all_sumBin                = cell(nRepeats,1);
    % 
    % % Get trial indices per type
    % trialTypeIdx_all = cell(numel(unTrialType),1);
    % nTrialsPerType   = zeros(numel(unTrialType),1);
    % for n_type = 1:numel(unTrialType)
    %     trialTypeIdx_all{n_type} = find(ismember(trialTypeSession, unTrialType(n_type)));
    %     nTrialsPerType(n_type)   = numel(trialTypeIdx_all{n_type});
    % end
    % minTrials = min(nTrialsPerType);  % balance to smallest count
    % % % %

    % % only keeping Small and Large
    % % Define which sizes to keep
    % sizesToKeep = {'Small', 'Large'};
    % size_labels = {'Small', 'Large'};
    % 
    % % Find indices of trials belonging to 'small' or 'large' sessions
    % SLsizeIdx = ismember(apertureSizeSession, sizesToKeep);
    % 
    % % Extract trials that correspond to 'small' or 'large' sessions
    % SessionData = SessionData(SLsizeIdx);
    % sessionLabels = sessionLabels(SLsizeIdx);
    % timePhaseLabels = timePhaseLabels(SLsizeIdx);
    % trialTypeSession = trialTypeSession(SLsizeIdx);
    % graspTypeSession = graspTypeSession(SLsizeIdx);
    % apertureSizeSession = apertureSizeSession(SLsizeIdx);
    % uniqueApertureSize = unique(apertureSizeSession);
    % sessionLabels_size = apertureSizeSession;
    % sessionLabels_size_num = zeros(size(sessionLabels_size));
    % for i = 1:length(size_labels)
    %     sessionLabels_size_num(strcmp(sessionLabels_size, size_labels{i})) = i;
    % end

    % loop through cue conditions 
    for n_type = 1:numel(unTrialType)
        trialTypeIdx = ismember(trialTypeSession, unTrialType(n_type));
        %SessionData = SessionData(trialTypeIdx); % keep data only for Combined trials
        %timePhaseLabels = timePhaseLabels(trialTypeIdx); % keep timePhaseLabels for Combined trials only

        % sessionLabels_object = sessionLabels_object(trialTypeIdx); % pulls out names for objects
        % sessionLabels_object_num = sessionLabels_object_num(trialTypeIdx); % for object tuning, idx so only Combined dataset used
        % sessionLabels_grasp = sessionLabels_grasp(trialTypeIdx); % TEST pulls out names for grasps
        % sessionLabels_grasp_num = sessionLabels_grasp_num(trialTypeIdx); % TEST for grasp tuning, idx so only Combined dataset used

        % for n_object = 1:numel(object_labels) % loop through each object to test tuning to each grasp

            %objectTypeIdx = ismember(sessionLabels_object, object_labels(n_object)); 

        %for n_grasp = 1:numel(grasp_labels) % TEST loop through each grasp to test tuning to each object

            %graspTypeIdx = ismember(sessionLabels_grasp, grasp_labels(n_grasp)); % TEST

         if flagTunedChannels
            %Compute index of units that are tuned
            if flagRegressionTuning
            
                % [tunedCombinedChannels, tunedChannelsPhase, tunedChannelsBin, sumPhase, sumBin,numTunedChannelsPerCategory,~,~,p_per_phase] ...
                %      = classification.getRegressionTunedChannels_paper(SessionData(trialTypeIdx),sessionLabels(trialTypeIdx), ...
                %  timePhaseLabels(trialTypeIdx), 'multcompare',multipleComparePhase, 'BinperBinTuning', flagBinPerBin); % original code
                % % % % ADDRESSING UNEQUAL TRIAL NUMBERS % % %
                % if n_type == 1 % USE WHEN COMBINED DATASET/UNEQUAL TRIALS
                %     % separate out Combined dataset
                %     combinedData = SessionData(trialTypeIdx);
                %     %combined_grasp_labels = sessionLabels_grasp_num(trialTypeIdx);
                %     combined_object_labels = sessionLabels_object_num(trialTypeIdx);
                %     combinedTimePhaseLabels = timePhaseLabels(trialTypeIdx);
                %     %use cvpartition to randomly select trials within the
                %     %combined dataset to even out #s of trials
                %     tunedPhaseMat = [];
                %     tunedBinMat = [];
                %     combinedIdx   = trialTypeIdx_all{n_type};
                %     % for grasps
                %     % graspVars = graspTypeSession(combinedIdx);
                %     % uniqueGrasps = unique(graspVars);
                %     % for objects
                %     objectVars = objectTypeSession(combinedIdx);
                %     uniqueObjects = unique(objectVars);
                % 
                %     % count per grasp
                %     % countsPerGrasp = histcounts(categorical(graspVars));
                %     % minPerGrasp = min(countsPerGrasp);
                %     % counts per object
                %     countsPerObject = histcounts(categorical(objectVars));
                %     minPerObject = min(countsPerObject);
                % 
                %     % to keep total minTrialsPerType
                %     %perGraspTarget = floor(minTrials / numel(uniqueGrasps));
                %     % target objects
                %     perObjectTarget = floor(minTrials / numel(uniqueObjects));
                % 
                %     for r = 1:nRepeats
                %         balancedIdx = [];
                %         keepIdx = [];
                %         for g = 1:numel(uniqueObjects) %numel(uniqueGrasps)
                %             % per grasp index
                %             %gIdx = find(strcmpi(graspVars, uniqueGrasps(g)));
                %             % per object idx
                %             oIdx = find(strcmpi(objectVars, uniqueObjects(g)));
                %             % subsample per grasp
                %             c = cvpartition(numel(oIdx),'HoldOut',perObjectTarget); %numel(gIdx),'HoldOut',perGraspTarget);
                %             gKeep = oIdx(test(c)); %gIdx
                % 
                %             % Map back to session-wide indices
                %             keepIdx = [keepIdx; combinedIdx(gKeep)];
                %         end
                % 
                %         balancedIdx = ismember(combinedIdx, keepIdx);
                % 
                %          [tunedCombinedChannels_r, tunedChannelsPhase_r, tunedChannelsBin_r, sumPhase_r, sumBin_r,numTunedChannelsPerCategory_r,~,~,p_per_phase_r] ...
                %              = classification.getRegressionTunedChannels_paper(combinedData(balancedIdx),combined_object_labels(balancedIdx), ...
                %          combinedTimePhaseLabels(balancedIdx), 'multcompare',multipleComparePhase, 'BinperBinTuning', flagBinPerBin); % for grasp/object
                % 
                %          %condToTest = arrayfun(@(x) grasp_labels(x),unique(sessionLabels_grasp_num),'UniformOutput',false); % testing for tuning to grasp
                %          condToTest = arrayfun(@(x) object_labels(x),unique(combined_object_labels),'UniformOutput', false); % testing for tuning to object
                % 
                %          % Store results needed for downstream analysis
                %         all_sumPhase{r}              = sumPhase_r;
                %         all_sumBin{r}                = sumBin_r;
                %         tunedPhaseMat = cat(3, tunedPhaseMat, tunedChannelsPhase_r);
                %         tunedBinMat = cat(4, tunedBinMat, tunedChannelsBin_r);
                % 
                %     end
                % 
                %     % sum number of tuned channels and divide by nRepeats
                %     sumPhase = round((sum(cat(3, all_sumPhase{:}), 3))/nRepeats);
                %     sumBin   = round(sum(cat(3, all_sumBin{:}), 3)/nRepeats);
                % 
                %     % Consensus rule: tuned if tuned ≥50% of repetitions
                %     % (somewhat arbitrary but only use the sums downstream
                %     % so this is more to keep the format the same across
                %     % each condition)
                %     tunedChannelsPhase = mean(tunedPhaseMat,3) >= 0.5;
                %     tunedChannelsBin = mean(tunedBinMat,4) >= 0.5;
                % 
                % 
                % else
                % % % % 
                    [tunedCombinedChannels, tunedChannelsPhase, tunedChannelsBin, sumPhase, sumBin,numTunedChannelsPerCategory,~,~,p_per_phase] ...
                         = classification.getRegressionTunedChannels_paper(SessionData(trialTypeIdx),sessionLabels_grasp_num(trialTypeIdx), ...
                     timePhaseLabels(trialTypeIdx), 'multcompare',multipleComparePhase, 'BinperBinTuning', flagBinPerBin); % for size/grasp

                 % [tunedCombinedChannels, tunedChannelsPhase, tunedChannelsBin, sumPhase, sumBin,numTunedChannelsPerCategory,~,~,p_per_phase] ...
                 %     = classification.getRegressionTunedChannels_paper(SessionData(trialTypeIdx),sessionLabels_object_num, ...
                 % timePhaseLabels(trialTypeIdx), 'multcompare',multipleComparePhase, 'BinperBinTuning', flagBinPerBin); % for object

                % [tunedCombinedChannels, tunedChannelsPhase, tunedChannelsBin, sumPhase, sumBin,numTunedChannelsPerCategory,~,~,p_per_phase] ...
                %      = classification.getRegressionTunedChannels_paper(SessionData(graspTypeIdx),sessionLabels_object_num(graspTypeIdx), ...
                %  timePhaseLabels(graspTypeIdx), 'multcompare',multipleComparePhase, 'BinperBinTuning', flagBinPerBin); % for grasp tuning per object and object tuning per grasp

                %condToTest = arrayfun(@(x) preproc.image2class_simple(x),unique(sessionLabels), 'UniformOutput', false); % original
                condToTest = arrayfun(@(x) grasp_labels(x),unique(sessionLabels_grasp_num),'UniformOutput',false); % testing for tuning to grasp
                %condToTest = arrayfun(@(x) size_labels(x),unique(sessionLabels_size_num),'UniformOutput', false); % testing for tuning to size
                %condToTest = arrayfun(@(x) object_labels(x),unique(sessionLabels_object_num),'UniformOutput', false); % testing for tuning to object
                %end

                if nnz(sumBin) ~= 0
                    figure();
                    plot(sumBin);
                end

                tuned_channels_per_grasp{n_type,n_session} = numTunedChannelsPerCategory;
                %tuned_channels_per_size{n_type,n_session} = numTunedChannelsPerCategory;
                %tuned_channels_per_object{n_type,n_session} = numTunedChannelsPerCategory;
                %tuned_channels_per_object{n_object,n_session} = numTunedChannelsPerCategory; % combined tuning per object
                %tuned_channels_per_grasp{n_grasp,n_session} = numTunedChannelsPerCategory; % combined tuning per grasp
            else

                tuned_channels_per_grasp{n_type,n_session} = [];
                [tunedCombinedChannels, tunedChannelsPhase, tunedChannelsBin, sumPhase, sumBin]= classification.getTunedChannels(SessionData(trialTypeIdx),sessionLabels(trialTypeIdx), ...
                timePhaseLabels(trialTypeIdx), 'multcompare', multipleComparePhase,'removeITItuning', 'false', 'BinperBinTuning', flagBinPerBin);
                sumBin = sumBin';
            end

                if nnz(sumBin) > 0
                sum_bin_all{n_type, n_session } = sumBin;
                %sum_bin_all{n_grasp, n_session } = sumBin; % TEST

                else
                sum_bin_all{n_type, n_session } = [];

                end

            tuned_channels_per_phase{n_type,n_session} = sumPhase; % original
            tuned_channels_per_phase_vector{n_type,n_session} = tunedChannelsPhase;
            tuned_channels_per_bin_vector{n_type,n_session} = tunedChannelsBin;

            % tuned_channels_per_phase{n_object,n_session} = sumPhase; % for grasp tuning per object
            % tuned_channels_per_phase_vector{n_object,n_session} = tunedChannelsPhase; 
            % tuned_channels_per_bin_vector{n_object,n_session} = tunedChannelsBin; 

            % tuned_channels_per_phase{n_grasp,n_session} = sumPhase; % TEST for object tuning per grasp
            % tuned_channels_per_phase_vector{n_grasp,n_session} = tunedChannelsPhase; % TEST
            % tuned_channels_per_bin_vector{n_grasp,n_session} = tunedChannelsBin; % TEST


         
         end
        %end
    end 

    % % calculating tuning overlap per phase 
    % hand     = tuned_phase_matrix(:,:,1);
    % ho       = tuned_phase_matrix(:,:,2);
    % object   = tuned_phase_matrix(:,:,3);
    % 
    % % Overlaps
    % hand_ho_overlap_vector        = hand & ho;
    % object_ho_overlap_vector      = object & ho;
    % object_hand_overlap_vector    = object & hand;
    % all_three_overlap_vector      = hand & ho & object;
    % 
    % % Count overlap units per phase
    % hand_ho_overlap_units         = sum(hand_ho_overlap_vector, 1);
    % object_ho_overlap_units       = sum(object_ho_overlap_vector, 1);
    % object_hand_overlap_units     = sum(object_hand_overlap_vector, 1);
    % object_hand_ho_overlap_units  = sum(all_three_overlap_vector, 1);
    % 
    % % Store units
    % hand_ho_overlap_units_all{n_session}        = hand_ho_overlap_units;
    % object_ho_overlap_units_all{n_session}      = object_ho_overlap_units;
    % object_hand_overlap_units_all{n_session}    = object_hand_overlap_units;
    % object_hand_ho_overlap_units_all{n_session} = object_hand_ho_overlap_units;
end 

% hand_ho_overlap_units_all_sessions = sum(cell2mat(hand_ho_overlap_units_all));
% object_ho_overlap_units_all_sessions = sum(cell2mat(object_ho_overlap_units_all));
% object_hand_overlap_units_all_sessions = sum(cell2mat(object_hand_overlap_units_all));
% object_hand_ho_overlap_units_all_sessions = sum(cell2mat(object_hand_ho_overlap_units_all));
% 
% hand_total_units = sum(cell2mat(tuned_channels_per_phase(1,:)'));
% ho_total_units = sum(cell2mat(tuned_channels_per_phase(2,:)'));
% object_total_units = sum(cell2mat(tuned_channels_per_phase(3,:)'));

%%
% n_phases = numel(phase_bin_ranges);
% n_sessions = size(tuned_channels_per_bin_vector, 2);
% 
% % Store unit indices (logical) per condition, per phase, per session
% exclusive = cell(numel(unTrialType), n_phases, n_sessions); % binary vector [n_units x 1]
% exclusive_timecourse = cell(numel(unTrialType), n_phases, n_sessions);
% exclusive_percentage = cell(numel(unTrialType), n_phases, n_sessions);
% all3_percentage = cell(n_phases, n_sessions);
% 
% for sess = 1:n_sessions
%     % Pull bin tuning for this session and all 3 conditions
%     bin_tuning = cell(numel(unTrialType), 1);
%     for cond = 1:numel(unTrialType)
%         bin_tuning{cond} = tuned_channels_per_bin_vector{cond, sess}; % [n_units x n_timebins]
%     end
% 
%     n_units = size(bin_tuning{1}, 3);  % assumes same across conditions
% 
%     for p = 1:n_phases
%         bins = phase_bin_ranges{p};
%         n_bins = numel(bins);
% 
%         % Step 1: Extract tuning for each condition during this phase
%         tuning_in_phase = cellfun(@(x) squeeze(x(bins, p, :)), bin_tuning, 'UniformOutput', false); 
%         % Now tuning_in_phase{cond} is [n_bins x n_units]
% 
%         % Step 2: Logical AND across all 3 conditions
%         tuned_all3 = tuning_in_phase{1} & tuning_in_phase{2} & tuning_in_phase{3};  % [n_bins x n_units]
% 
%         % Step 3: Compute percent of total units tuned at each bin
%         perc_all3 = sum(tuned_all3, 2)' / n_units * 100;  % [1 x n_bins]
% 
%         % Optional: Save the logical mask itself if needed
%         tuned_all3_logical{p, sess} = tuned_all3;  % [n_bins x n_units]
% 
%         % Save percentage
%         all3_percentage{p, sess} = perc_all3;  % [1 x n_bins]
% 
%         % Step 4: Find which units are tuned during the phase, per condition
%         tuning_in_phase = cellfun(@(x) squeeze(x(bins, p, :)), bin_tuning, 'UniformOutput', false); 
%         for cond = 1:numel(unTrialType)
%             % Get this condition's tuning: [n_bins x n_units]
%             this_cond_tuning = tuning_in_phase{cond};
% 
%             % Get tuning for all other conditions
%             other_conds = setdiff(1:numel(unTrialType), cond);
%             other_tuning = cell2mat(reshape(tuning_in_phase(other_conds), 1, 1, []));  % [n_bins x n_units*(n_conditions-1)]
%             % Reshape to [n_bins x n_units x n_other_conditions]
%             other_tuning = reshape(other_tuning, n_bins, n_units, []);
% 
%             % Exclusive if tuned in this cond AND not in any other cond
%             is_exclusive = this_cond_tuning & ~any(other_tuning, 3);  % [n_bins x n_units]
% 
%             % Percent of total units tuned exclusively at each bin
%             perc_exclusive = sum(is_exclusive, 2)' / n_units * 100;  % [1 x n_bins]
% 
%             exclusive_percentage{cond, p, sess} = perc_exclusive;
%         end
%     end
% end
% 
% %
% total_bins = numel(phase_time_idx);
% % Prepare containers
% exclusive_concat = cell(numel(unTrialType), 1);
% per_bin_yCI95 = zeros(numel(unTrialType), total_bins);
% per_bin_tuned_mean = zeros(numel(unTrialType), total_bins);
% all3_percent_all_sessions = zeros(n_sessions,total_bins);
% 
% % Concatenate across phases for continuous time
% for sess = 1:n_sessions
%     all_bins = [];
%     for p = 1:n_phases
%         all_bins = [all_bins, all3_percentage{p, sess}];
%     end
%     all3_percent_all_sessions(sess, :) = all_bins;  % [n_sessions x total_bins]
% end
% 
% mean_all3 = mean(all3_percent_all_sessions, 1, 'omitnan');
% CI95_all3 = utile.calculate_CI(all3_percent_all_sessions); % [2 x bins]
% sem_all3 = CI95_all3(2,:); % or CI95 if that’s what you want
% 
% for cond = 1:numel(unTrialType)
%     concatenated_data = NaN(n_sessions, total_bins);
% 
%     for sess = 1:n_sessions
%         this_session = [];
% 
%         for p = 1:n_phases
%             this_phase = exclusive_percentage{cond, p, sess}; % [1 x bins]
%             this_phase = this_phase(:)'; % ensure row
%             this_session = [this_session, this_phase];
%         end
% 
%         concatenated_data(sess, :) = this_session;
%     end
% 
%     exclusive_concat{cond} = concatenated_data;
% 
%     % Mean + 95% CI
%     per_bin_tuned_mean(cond, :) = mean(concatenated_data, 1, 'omitnan');
%     yCI95tmp = utile.calculate_CI(concatenated_data); % [2 x bins]
%     per_bin_yCI95(cond, :) = yCI95tmp(2,:);
% end
% 
% % Plot All Phases Continuous – Exclusive Units
% 
% figure('units','normalized','outerposition',[0 0 0.4 0.35]);
% err_bar = {};
% 
% for n_type = 1:numel(unTrialType)
%     hold on
%     err_bar{n_type} = plot(1:total_bins, per_bin_tuned_mean(n_type,:), ...
%         'Color', color_info{n_type}, 'LineWidth', 2);
% 
%     ER = utile.shadedErrorBar(1:total_bins, ...
%         per_bin_tuned_mean(n_type,:), per_bin_yCI95(n_type,:));
%     ER.mainLine.Color = color_info{n_type};
%     ER.patch.FaceColor = color_info{n_type};
%     ER.edge(1).LineStyle = 'none';
%     ER.edge(2).LineStyle = 'none';
% end
% 
% % Add 'All 3' condition to plot
% hold on;
% err_bar{4} = plot(1:total_bins, mean_all3, 'Color', [0.3 0.3 0.3], 'LineWidth', 2); % dark gray
% 
% ER = utile.shadedErrorBar(1:total_bins, mean_all3, sem_all3);
% ER.mainLine.Color = [0.3 0.3 0.3];
% ER.patch.FaceColor = [0.3 0.3 0.3];
% ER.edge(1).LineStyle = 'none';
% ER.edge(2).LineStyle = 'none';
% 
% % Add vertical lines for phase boundaries
% for n_phase = 1:numPhases
%     xline(phase_changes(n_phase), 'k--', phaseNames{n_phase}, 'LineWidth', 1.5,'FontSize',12);
% end
% 
% title([unit_region ' – Exclusive Units Across Trial']);
% xlabel('Time (s)');
% xlim([30 134]); 
% xticks(phase_changes);
% xticklabels([0 2 4 6]);
% xtickangle(45);
% ylabel('% of Total Units');
% ylim([0 40]);
% yticks([0 20 40]);
% legend([err_bar{:}], 'Hand', 'Hand+Object', 'Object', 'All 3', 'Location', 'Best', ...
%     'Interpreter', 'none', 'FontSize', 12);
% set(gca, 'FontSize', 12);

%% saving variables
goLabel = ["NoGo", "Go"];
goLabel = goLabel(flagGoTrials + 1);

% Create the filename using the brain region and analysis type
%filename = ['tuned_channels_per_condition' TaskCue '_' unit_region '_' analysis_type '_' goLabel '.mat']; % goLabel determines Go, NoGo label
filename = "grasp_tuned_channels_per_condition_" + TaskCue + '_' + unit_region + "_" + analysis_type + "_" + goLabel + ".mat"; % just .mat for original data
%filename = "balanced_object_tuned_channels_per_condition_" + TaskCue + '_' + unit_region + "_" + analysis_type + "_" + goLabel + ".mat"; 
%filename = "TEST_balanced_grasp_tuned_channels_per_condition_" + TaskCue + '_' + unit_region + "_" + analysis_type + "_" + goLabel + "_z_scored.mat"; % when z-scoring

directory = ['C:\Users\macthurston\Documents\GitHub\project_grasp_object_interaction\analyzedData\' subject_id];
full_path = fullfile(directory, filename);

% Save the relevant variables with the dynamic filename
%save(full_path, 'sum_bin_all', 'tuned_channels_per_phase', 'tuned_channels_per_phase_vector','tuned_channels_per_bin_vector','numUnitsPerSession',...
    % 'hand_ho_overlap_units_all','object_ho_overlap_units_all','object_hand_overlap_units_all','object_hand_ho_overlap_units_all',...
    % 'hand_ho_overlap_units_all_sessions','object_ho_overlap_units_all_sessions','object_hand_overlap_units_all_sessions','object_hand_ho_overlap_units_all_sessions',...
    % 'hand_total_units','ho_total_units','object_total_units'); % for overlap

save(full_path, 'sum_bin_all', 'tuned_channels_per_phase', 'tuned_channels_per_phase_vector','tuned_channels_per_bin_vector','numUnitsPerSession'); % object tuning for Combo dataset
%%
keyboard

%% across sessions tuned units overlapping 

% tuned_channels_per_phase_vector; % 3 (modality) x 5 (sessions)
% % I can compare within sessions how much overlap there is and then average
% % the sessions together to get average overlap
% 
% % H-HO overlap
% hand_ho_overlap_vector = (tuned_channels_per_phase_vector{1,1} == 1) & (tuned_channels_per_phase_vector{2,1} == 1); % this tells me the overlap between hand and hand-object units
% % I can sum and then substract from the total to get the venn diagram
% hand_ho_overlap_units = sum(hand_ho_overlap_vector, 1);
% 
% tuned_channels_per_phase; % total units for each modality
% hand_only_units = tuned_channels_per_phase{1,1} - hand_ho_overlap_units;
% ho_only_units_h = tuned_channels_per_phase{2,1} - hand_ho_overlap_units;
% 
% % next find average by iterating through each session and then finding the
% % mean
% 
% % O-HO overlap
% object_ho_overlap_vector = (tuned_channels_per_phase_vector{3,1} == 1) & (tuned_channels_per_phase_vector{2,1} == 1); % this tells me the overlap between object and hand-object units
% % I can sum and then substract from the total to get the venn diagram
% object_ho_overlap_units = sum(object_ho_overlap_vector, 1);
% 
% tuned_channels_per_phase; % total units for each modality
% object_only_units = tuned_channels_per_phase{3,1} - object_ho_overlap_units;
% ho_only_units_o = tuned_channels_per_phase{2,1} - object_ho_overlap_units;
% 
% % next find average by iterating through each session and then finding the
% % mean
% 
% % O-H overlap
% object_hand_overlap_vector = (tuned_channels_per_phase_vector{3,1} == 1) & (tuned_channels_per_phase_vector{1,1} == 1); % this tells me the overlap between object and hand units
% % I can sum and then substract from the total to get the venn diagram
% object_hand_overlap_units = sum(object_hand_overlap_vector, 1);
% 
% tuned_channels_per_phase; % total units for each modality
% object_only_units_h = tuned_channels_per_phase{3,1} - object_hand_overlap_units;
% hand_only_units_o = tuned_channels_per_phase{1,1} - object_hand_overlap_units;
% 
% % next find average by iterating through each session and then finding the
% % mean
% 
% % all 3 modalities overlap
% object_hand_ho_overlap_vector = (tuned_channels_per_phase_vector{3,1} == 1) & (tuned_channels_per_phase_vector{1,1} == 1) & (tuned_channels_per_phase_vector{2,1} == 1); % this tells me the overlap between object and hand units
% % I can sum and then substract from the total to get the venn diagram
% object_hand_ho_overlap_units = sum(object_hand_ho_overlap_vector, 1);
% 
% tuned_channels_per_phase; % total units for each modality
% object_only_units_h = tuned_channels_per_phase{3,1} - object_hand_overlap_units;
% hand_only_units_o = tuned_channels_per_phase{1,1} - object_hand_overlap_units;

%% example (requires Statistics and Machine Learning Toolbox) => unsure if
% % can handle 3 inputs
% % Sample data (replace with your own data)
% set1 = randi([0, 1], 1, 100); % Binary data for set 1
% set2 = randi([0, 1], 1, 100); % Binary data for set 2
% 
% % Create a logical array for the Venn diagram
% venn_data = [sum(set1 & ~set2), sum(~set1 & set2), sum(set1 & set2)];
% 
% % Create a Venn diagram using vennplot
% figure;
% vennplot(venn_data, 'FaceColor', {'r', 'g', 'b'}, 'FaceAlpha', 0.5);
% 
% % Add labels
% vennlabel({'Set 1', 'Set 2'});
% 
% % Add a title
% title('Venn Diagram');
% 
% % Adjust the display
% axis equal;

%% load Data
goLabel = ["NoGo", "Go"];
goLabel = goLabel(flagGoTrials + 1);
directory = ['C:\Users\macthurston\Documents\GitHub\project_grasp_object_interaction\analyzedData\' subject_id];
analysis_type = 'LinearRegression'; % 'LinearRegression' or 'KW'
%filename = "grasp_tuned_channels_per_condition_" + TaskCue + '_' + unit_region + "_" + analysis_type + "_" + goLabel + ".mat"; % just .mat for original data
filename = "tuned_channels_" + TaskCue + '_' + unit_region + "_" + analysis_type + "_" + 'Pixelated'; % Pixelated/Regular
full_path = fullfile(directory, filename);
load(full_path);

%% creating bar plots of overlap

% Define phase indices (e.g., Cue = 2, Action = 4)
phase_names = {'Cue', 'Action'};
phase_indices = [2, 4];
n_phases = numel(phase_indices);

% Preallocate output
overlap_counts = zeros(n_phases, 7); % columns: [All3, H∩O, H∩HO, O∩HO, H only, O only, HO only]
overlap_perc   = zeros(n_phases, 7);

for p = 1:n_phases
    phase = phase_indices(p);

    % Get overlaps for this phase
    all3      = object_hand_ho_overlap_units_all_sessions(phase);
    h_o       = object_hand_overlap_units_all_sessions(phase) - all3;
    h_ho      = hand_ho_overlap_units_all_sessions(phase) - all3;
    o_ho      = object_ho_overlap_units_all_sessions(phase) - all3;

    % Get unique (non-overlapping) units per condition
    h_only    = hand_total_units(phase) - (all3 + h_o + h_ho);
    o_only    = object_total_units(phase) - (all3 + h_o + o_ho);
    ho_only   = ho_total_units(phase) - (all3 + h_ho + o_ho);

    % Total
    total_units = all3 + h_o + h_ho + o_ho + h_only + o_only + ho_only;

    % Store counts
    overlap_counts(p, :) = [h_only,h_ho,ho_only,all3,o_ho,o_only,h_o]; %[all3, h_o, h_ho, o_ho, h_only, o_only, ho_only];

    % Store percentages
    overlap_perc(p, :) = (overlap_counts(p, :) / total_units) * 100;
end

% look at all conditions
conditionLabels = categorical({'H','H&HO','HO','H&HO&O','HO&O','O','O&H'});
conditionLabels = reordercats(conditionLabels,{'H','H&HO','HO','H&HO&O','HO&O','O','O&H'});

% Create the first bar chart
b1 = bar(conditionLabels, overlap_perc(1,:), 'FaceColor', 'b', 'FaceAlpha', 0.5); % Blue bars with transparency
hold on;

% Create the second bar chart
b2 = bar(conditionLabels, overlap_perc(2,:), 'FaceColor', 'r', 'FaceAlpha', 0.5); % Red bars with transparency

% Add labels and legend
xlabel('Condition');
ylabel('% of Tuned Units');
legend({'Cue', 'Action'});
title(['Overlapping Units Throughout Trial - ' unit_region]);

hold off;
%%
% look at overlap of all 3 conditions with SDs
% okay so hand_total_units gives the total number of tuned units during the
% H blocks across all sessions, same for the others (can also look at
% tuned_units_per_phase if needed). we also have the values of tuned units
% for the overlap of all 3 for each individual session stored in
% object_hand_ho_overlap_all. I want to look at the percentage of tuned
% units contained in the all overlapping condition, so I think I need to add the
% tuned units that were present in each condition and use that as the
% denomiator

allOverlap = cell2mat(object_hand_ho_overlap_units_all);
percentageOverlap = cell(numSessions,1);

for n_session = 1:numSessions
    overlap_cue = allOverlap(n_session,2);
    overlap_action = allOverlap(n_session,4);

    tmpData = cell2mat(tuned_channels_per_phase(:,n_session));
    total_units_cue = sum(tmpData(:,2));
    total_units_action = sum(tmpData(:,4));
    percentageOverlap{n_session} = [(overlap_cue/total_units_cue)*100 (overlap_action/total_units_action)*100];
end

% now find mean and SD


%% bar plot of tuned units w/ 95% CIs (work on getting them all on same plot)
%save('C:\Users\macthurston\OneDrive - Kaiser Permanente\CaltechData\GraspObject_project\Workspaces\LinearRegression\s2\s2_GraspObject_2S_unsorted_aligned_thr_-4.5_SMG_Example.mat','sum_bin_all')
%ExampleSMG = load('C:\Users\macthurston\OneDrive - Kaiser Permanente\CaltechData\GraspObject_project\Workspaces\LinearRegression\s2\s2_GraspObject_2S_unsorted_aligned_thr_-4.5_SMG_Example.mat');
% upload linear regression analysis
%load('C:\Users\macthurston\OneDrive - Kaiser Permanente\CaltechData\GraspObject_project\Workspaces\LinearRegression\s2\s2_GraspObject_2S_unsorted_aligned_thr_-4.5_PMV.mat');

% phase_yCI95 = [];
% phase_tuned_mean = [];
phase_tuned_mean_all = zeros(numel(taskCuesAll), numPhases); % Mean percentages
phase_yCI95_all = zeros(numel(taskCuesAll), numPhases); % 95% CI
percentage_tuned_all = cell(numel(taskCuesAll), 1);
%sessionToInclude = setdiff(1:numSessions,1);

% code for empty/missing session data
rowsToKeep = numUnitsPerSession ~= 0;
numUnitsPerSession = numUnitsPerSession(rowsToKeep);
sessionToInclude = 1:numel(numUnitsPerSession);
colsToKeep = true(1,numSessions);
for n_session = 1:numSessions
    if all(cellfun('isempty',tuned_channels_per_phase(:,n_session)))
        colsToKeep(n_session) = false;
    end
end
tuned_channels_per_phase = tuned_channels_per_phase(:,colsToKeep);

figure('units','normalized','outerposition',[0 0 .38 0.38]); %[0 0 .5 .5]); %[0 0 .38 0.38]);
for n_type = 1:numel(taskCuesAll)
    dataTmp = cell2mat(tuned_channels_per_phase(n_type,sessionToInclude)')*100;
    percentage_tuned = dataTmp./numUnitsPerSession(sessionToInclude);
    percentage_tuned_all{n_type} = percentage_tuned;
    yCI95tmp = utile.calculate_CI(percentage_tuned); % Calculate 95% Probability Intervals Of t-Distribution using SEM
    phase_yCI95_all(n_type,:) = yCI95tmp(2,:);
    phase_tuned_mean_all(n_type,:) = mean(percentage_tuned,1);

    % figure()
    subplot(1,numel(taskCuesAll),n_type)

    hold on
    bar(phase_tuned_mean_all(n_type,:),'FaceColor',color_info{n_type});

    hold on
    errorbar(phase_tuned_mean_all(n_type,:),phase_yCI95_all(n_type,:),'Color','k');

    % Scatter plot of individual session data points
    for n_phase = 1:4
        scatter(repmat(n_phase, numel(sessionToInclude), 1), percentage_tuned(:,n_phase), 50, 'k', 'filled', 'MarkerFaceAlpha', 0.6);
    end 

    title(taskCuesAll(n_type));
    xticks(1:numel(phaseNames));
    xticklabels(phaseNames);
    xtickangle(45);
    ylabel('% of Total Units');
    ylim([0 100]);
    yticks([0 50 100]);
    sgtitle(['Tuned Units in ' unit_region])
    set(gca, 'FontSize', 12);
end
%% ANOVA for percentage tuned
% formatting the data
numModalities = numel(taskCuesAll);

% Initialize the 3D array
percentage_tuned_3D = zeros(numSessions, numPhases, numModalities);

% Loop through each modality and fill the 3D array
for n_modality = 1:numModalities
    % Extract the data from the cell
    current_data = percentage_tuned_all{n_modality};
    
    % Check the size of current_data
    [numSessionsCheck, numPhasesCheck] = size(current_data);
    
    % Ensure the size matches the expected dimensions
    if numSessionsCheck ~= numSessions || numPhasesCheck ~= numPhases
        error('The dimensions of the data in cell %d do not match expected dimensions.', n_modality);
    end
    
    % Fill the 3D array
    percentage_tuned_3D(:, :, n_modality) = current_data;
end

[numSessions, numPhases, numModalities] = size(percentage_tuned_3D);

% Loop through each phase
for n_phase = 1:numPhases
    % Extract data for the current phase
    phaseData = squeeze(percentage_tuned_3D(:, n_phase, :)); % Shape: [numSessions, numModalities]

    % Reshape data for ANOVA
    data = [];
    modality = [];

    % Loop through each modality
    for n_modality = 1:numModalities
        % Append the classification percentage
        data = [data; phaseData(:, n_modality)];
        % Append modality identifier
        modality = [modality; repmat(n_modality, numSessions, 1)];
    end

    % Convert modality to categorical for ANOVA
    modality = categorical(modality);

    % Create a table with the reshaped data
    dataTable = table(data, modality);

    % Perform ANOVA for the current phase
    [p, tbl, stats] = anova1(dataTable.data, dataTable.modality, 'off');
    
    % Display ANOVA results
    disp(['Phase ' num2str(n_phase) ':']);
    disp(['p-value = ' num2str(p)]);
    
    % Perform post-hoc tests if ANOVA is significant
    if p < 0.05
        [c, m, h, gnames] = multcompare(stats, 'CType', 'tukey-kramer');
        disp('Post-hoc test results:');
        disp(c);
    end
end

%% bar plot w/o CIs
% variables
unTrialType = unique(Go_data.TrialType);

for n_type = 1%:numel(unTrialType) 
    if numSessions ~= 1
        tunedUnitsPerType(n_type,:) = sum(cell2mat(tuned_channels_per_phase(n_type,:)'));

    else
        tunedUnitsPerType(n_type,:) = cell2mat(tuned_channels_per_phase(n_type,:)');

    end 
end

figure('units','normalized','outerposition',[0 0 0.12 0.25]); %[0 0 .35 .5]);[0 0 0.12 0.25]);
b = bar((tunedUnitsPerType'./sum(numUnitsPerSession))*100);
%bar((((tunedUnitsPerType')*8)./sum(numUnitsPerSession))*100);
%bar(tunedUnitsPerType');
hold on;
for k = 1:numel(b)
    b(k).FaceColor = color_info{k}; % Assign colors from cell array
end
title(unit_region); %(['Tuned Units in ' unit_region]);
xticks(1:numel(phaseNames));
xticklabels(phaseNames);
ylabel('% of Total Units');
%ylabel('# of Tuned Units');
ylim([0 100]);
yticks([0 50 100]);
%ylim([0 50]);
legend(taskCuesAll, 'Location', 'Best', 'Interpreter', 'none','FontSize',12);
set(gca, 'FontSize', 12);
hold off

% % for F30
% phaseNames = {'Action'};
% taskCuesAll = {'G', 'G+O'};
% %tuned_channels_per_phase = [23 36; 38 47]; % pulling out cue and action of H & H+O, specific session for proposal
% tuned_channels_per_phase = [50; 56]; % pulling out action of H & H+O, specific session for proposal
% %tuned_channels_per_phase = [20 39; 30 46]; % SMG - pulling out cue and
% %action of H & H+O, specific session for proposal, OVERLAPPING UNITS found
% %in hand_ho_overlap_units for each phase
% %tuned_channels_per_phase = [5 24; 16 26]; % AIP - cue and action for H & HO
% %tuned_channels_per_phase = [34 50; 38 56]; % M1 - cue and action for H & HO
% 
% tunedUnitsPerType = tuned_channels_per_phase;
% figure('Position',[500 500 200 300]);
% h = bar((tunedUnitsPerType'./sum(numUnitsPerSession))*100, 'FaceColor','flat');
% h.CData(1,:) = [0.1176, 0.5333, 0.8980];
% h.CData(2,:) = [0.8471, 0.1059, 0.3765];
% %bar((((tunedUnitsPerType')*8)./sum(numUnitsPerSession))*100);
% %bar(tunedUnitsPerType');
% hold on;
% %title([unit_region ' - ' phaseNames]);
% xticks(1:numel(taskCuesAll));
% xticklabels(taskCuesAll);
% xlim([0.5, 2.5]);
% %ylabel('% of Total Units');
% %ylabel('# of Tuned Units');
% ylim([0 100]);
% yticks([0 50 100]);
% %ylim([0 50]);
% %legend(taskCuesAll, 'Location', 'Best', 'Interpreter', 'none','FontSize',12);
% set(gca, 'FontSize', 12);
% hold off

%% line plot w/o CIs

for n_type = 1:numel(unTrialType)
    tunedUnitsPerTypeBin(n_type,:)  = sum(cell2mat(sum_bin_all(n_type,:)),2);

end 

figure('units','normalized','outerposition',[0 0 0.3 0.45]);
lp = plot((tunedUnitsPerTypeBin'./sum(numUnitsPerSession))*100,'LineWidth',2);
%plot((((tunedUnitsPerTypeBin')*8)./sum(numUnitsPerSession))*100,'LineWidth',2);
%plot(tunedUnitsPerTypeBin','LineWidth',2);
hold on
for n_phase = 1:numPhases
    xline(phase_changes(n_phase), 'k--', phaseNames{n_phase}, 'LineWidth', 1.5,'FontSize',12);
end
for k = 1:numel(lp)
    lp(k).Color = color_info{k}; % Assign colors manually
end
title(['Tuned Units Throughout Trial in ' unit_region ' - ' sessions_all{n_session}]);
xlabel('Time Bins (50 ms)');
xlim([0 (min_timebin_length + 5)])
%xticks([0 50 100 150]);
ylabel('% of Total Units');
%ylabel('# of Tuned Units');
ylim([0 100]);
%yticks([0 20 40 60]);
%ylim([0 50]);
legend(taskCuesAll, 'Location', 'Best','FontSize',12);
set(gca, 'FontSize', 12);
hold off

%% plotting sessions individually

figure('units','normalized','outerposition',[0 0 .5 0.4]); % Wider figure for multiple subplots

for s = 1:4
    subplot(ceil(numSessions/2), 2, s); % Adjust rows/columns for your layout
    hold on

    for n_type = 1:numel(unTrialType)
        % Get tuning per time bin for this type and session
        sessionData = sum_bin_all{n_type, s}; % Should be timebins x 1
        % Normalize by total units in this session if desired
        plot((sessionData ./ numUnitsPerSession(s)) * 100, 'LineWidth', 2, 'Color', color_info{n_type});
    end

    for n_phase = 1:numPhases
        xline(phase_changes(n_phase), 'k--', phaseNames{n_phase}, 'LineWidth', 1.2,'FontSize',10);
    end

    title(['Session ' sessions_all{s}]);
    xlabel('Time Bins (50 ms)');
    ylabel('% Tuned Units');
    ylim([0 100]);
    xlim([0 min_timebin_length + 5]);
    set(gca, 'FontSize', 10);
    if s == 1
        legend(taskCuesAll, 'Location', 'Best','FontSize',9);
    end
    hold off
end

sgtitle(['Tuned Units Throughout Trial in ' unit_region], 'FontSize', 14);


%% for line plot w/ 95% CI
% Initialize variables
percentage_tuned_per_bin_all = cell(numel(taskCuesAll), 1);
per_bin_yCI95 = zeros(numel(taskCuesAll),min_timebin_length);
per_bin_tuned_mean = zeros(numel(taskCuesAll),min_timebin_length);
%sessionToInclude = setdiff(1:numSessions,1);
%color_info = {[0.2, 0.13, 0.53], [0.067, 0.467, 0.2], [0.53, 0.8, 0.93], [0.53, 0.13, 0.33]}; % grasps/objects: Purple, Green, Light Blue, Dark Pink

%code for empty/missing session data
rowsToKeep = numUnitsPerSession ~= 0;
numUnitsPerSession = numUnitsPerSession(rowsToKeep);
sessionToInclude = 1:numel(numUnitsPerSession);
colsToKeep = true(1,numSessions);
for n_session = 1:numSessions
    if all(cellfun('isempty',sum_bin_all(:,n_session)))
        colsToKeep(n_session) = false;
    end
end
sum_bin_all = sum_bin_all(:,colsToKeep);

figure('units','normalized','outerposition',[0 0 0.137 0.163]); %[0 0 0.5 0.45]) %[0 0 0.25 0.245]);
err_bar = {};
for n_type = 1:numel(taskCuesAll) %grasp_labels) %taskCuesAll)
    dataTmp = cell2mat(sum_bin_all(n_type,sessionToInclude))*100;
    percentage_tuned_per_bin = dataTmp./(numUnitsPerSession(sessionToInclude)');
    percentage_tuned_per_bin_all{n_type} = percentage_tuned_per_bin;
    yCI95tmp = utile.calculate_CI(percentage_tuned_per_bin');
    per_bin_yCI95(n_type,:) = yCI95tmp(2,:);
    per_bin_tuned_mean(n_type,:) = mean(percentage_tuned_per_bin,2);

    hold on
    err_bar{n_type} = plot(1:length(dataTmp),per_bin_tuned_mean(n_type,:),'Color', color_info{n_type},'LineWidth',2);

    ER = utile.shadedErrorBar(1:length(dataTmp),per_bin_tuned_mean(n_type,:),per_bin_yCI95(n_type,:));
    ER.mainLine.Color = color_info{n_type};
    ER.patch.FaceColor = color_info{n_type};
    ER.edge(1).LineStyle = 'none'; %color_info{n_type};
    ER.edge(2).LineStyle = 'none'; %color_info{n_type};
end

for n_phase = 1:numPhases
    xline(phase_changes(n_phase), 'k--', 'LineWidth', 1.5,'FontSize',12); %phaseNames{n_phase}
end

title(unit_region); %(['Tuned Units Throughout Trial in ' unit_region]);
xlabel('Timebins (50ms)');
xlim([30 134]); %shortened %(min_timebin_length + 5)]) % 5 chosen as a buffer
%xticks([1 42 83 124]);
%xticklabels(phase_names); %0 2 4 6
xtickangle(45);
ylabel('% of Total Units');
ylim([0 70]);
yticks([0 70]);
legend([err_bar{:}], taskCuesAll,'Location', 'Best','Interpreter', 'none','FontSize',12);
%legend([err_bar{:}], grasp_labels,'Location', 'Best','Interpreter', 'none','FontSize',12);
set(gca, 'FontSize', 12);

%% ANOVA for percentage tuned across first half of Cue
% I need to take the average percent of units across that 1st
% second for each session and then use those averages to run ANOVA and
% determine if there are any differences => Cue timebins = 42-82 (can find
% with var phase_changes)

% formatting the data
numModalities = numel(taskCuesAll);
numTimebins = min_timebin_length;
% Define the timebins of interest (1st half of Cue)
timebins_of_interest = 42:61;
num_timebins_of_interest = length(timebins_of_interest);

% Initialize storage for averaged data
halfCue_ave_percentage_tuned = zeros(numSessions, numModalities);

% Loop through each modality
for n_modality = 1:numModalities
    % Extract the data from the cell
    current_data = percentage_tuned_per_bin_all{n_modality}';
    
    % Average across the timebins of interest for each session
    halfCue_ave_percentage_tuned(:, n_modality) = mean(current_data(:, timebins_of_interest), 2);
end

% Reshape data for ANOVA
data = [];
modality = [];

% Loop through each modality
for n_modality = 1:numModalities
    % Append the averaged percentage of tuned units
    data = [data; halfCue_ave_percentage_tuned(:, n_modality)];
    % Append modality identifier
    modality = [modality; repmat(n_modality, numSessions, 1)];
end

% Convert modality to categorical for ANOVA
modality = categorical(modality);

% Create a table with the reshaped data
dataTable = table(data, modality);

% Perform ANOVA
[p, tbl, stats] = anova1(dataTable.data, dataTable.modality, 'off');

% Display ANOVA results
disp('ANOVA Results:');
disp(['p-value = ' num2str(p)]);

% Perform post-hoc tests if ANOVA is significant
if p < 0.05
    [c, m, h, gnames] = multcompare(stats, 'CType', 'tukey-kramer');
    disp('Post-hoc test results:');
    disp(c);
end

%%
% blub = percentage_tuned.*numUnitsPerSession';
% blub2= mean(blub');
% figure(); plot(zscore(blub2)); hold on; plot(zscore(per_bin_tuned_mean(n_type,:)))